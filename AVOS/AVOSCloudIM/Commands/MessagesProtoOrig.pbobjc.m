// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto.orig

#import "LCIMProtocolBuffers_RuntimeSupport.h"
#import "MessagesProtoOrig.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - AVIMMessagesProtoOrigRoot

@implementation AVIMMessagesProtoOrigRoot

@end

#pragma mark - AVIMMessagesProtoOrigRoot_FileDescriptor

static LCIMFileDescriptor *AVIMMessagesProtoOrigRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static LCIMFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    LCIMDebugCheckRuntimeVersion();
    descriptor = [[LCIMFileDescriptor alloc] initWithPackage:@"push_server.messages"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum AVIMCommandType

LCIMEnumDescriptor *AVIMCommandType_EnumDescriptor(void) {
  static LCIMEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Session\000Conv\000Direct\000Ack\000Rcp\000Unread\000Logs\000"
        "Error\000Login\000Data\000Room\000Read\000Presence\000Repo"
        "rt\000Echo\000";
    static const int32_t values[] = {
        AVIMCommandType_Session,
        AVIMCommandType_Conv,
        AVIMCommandType_Direct,
        AVIMCommandType_Ack,
        AVIMCommandType_Rcp,
        AVIMCommandType_Unread,
        AVIMCommandType_Logs,
        AVIMCommandType_Error,
        AVIMCommandType_Login,
        AVIMCommandType_Data,
        AVIMCommandType_Room,
        AVIMCommandType_Read,
        AVIMCommandType_Presence,
        AVIMCommandType_Report,
        AVIMCommandType_Echo,
    };
    static const char *extraTextFormatInfo = "\017\000\'\000\001$\000\002&\000\003#\000\004#\000\005&\000\006$\000\007%\000\010%\000\t$\000\n$\000\013$\000\014(\000\r&\000\016$\000";
    LCIMEnumDescriptor *worker =
        [LCIMEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AVIMCommandType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AVIMCommandType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AVIMCommandType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AVIMCommandType_Session:
    case AVIMCommandType_Conv:
    case AVIMCommandType_Direct:
    case AVIMCommandType_Ack:
    case AVIMCommandType_Rcp:
    case AVIMCommandType_Unread:
    case AVIMCommandType_Logs:
    case AVIMCommandType_Error:
    case AVIMCommandType_Login:
    case AVIMCommandType_Data:
    case AVIMCommandType_Room:
    case AVIMCommandType_Read:
    case AVIMCommandType_Presence:
    case AVIMCommandType_Report:
    case AVIMCommandType_Echo:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AVIMOpType

LCIMEnumDescriptor *AVIMOpType_EnumDescriptor(void) {
  static LCIMEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Open\000Add\000Remove\000Close\000Opened\000Closed\000Quer"
        "y\000QueryResult\000Conflict\000Added\000Removed\000Sta"
        "rt\000Started\000Joined\000MembersJoined\000Left\000Mem"
        "bersLeft\000Results\000Count\000Result\000Update\000Upd"
        "ated\000Mute\000Unmute\000Status\000Members\000Join\000Inv"
        "ite\000Leave\000Kick\000Reject\000Invited\000Kicked\000Upl"
        "oad\000Uploaded\000";
    static const int32_t values[] = {
        AVIMOpType_Open,
        AVIMOpType_Add,
        AVIMOpType_Remove,
        AVIMOpType_Close,
        AVIMOpType_Opened,
        AVIMOpType_Closed,
        AVIMOpType_Query,
        AVIMOpType_QueryResult,
        AVIMOpType_Conflict,
        AVIMOpType_Added,
        AVIMOpType_Removed,
        AVIMOpType_Start,
        AVIMOpType_Started,
        AVIMOpType_Joined,
        AVIMOpType_MembersJoined,
        AVIMOpType_Left,
        AVIMOpType_MembersLeft,
        AVIMOpType_Results,
        AVIMOpType_Count,
        AVIMOpType_Result,
        AVIMOpType_Update,
        AVIMOpType_Updated,
        AVIMOpType_Mute,
        AVIMOpType_Unmute,
        AVIMOpType_Status,
        AVIMOpType_Members,
        AVIMOpType_Join,
        AVIMOpType_Invite,
        AVIMOpType_Leave,
        AVIMOpType_Kick,
        AVIMOpType_Reject,
        AVIMOpType_Invited,
        AVIMOpType_Kicked,
        AVIMOpType_Upload,
        AVIMOpType_Uploaded,
    };
    static const char *extraTextFormatInfo = "#\000$\000\001#\000\002&\000\003%\000\004&\000\005&\000\006%\000\007%\246\000\010(\000\t%\000\n\'\000\013%\000\014\'\000\r&\000\016\'\246\000\017$\000\020\'\244\000\021\'\000\022%\000\023&\000\024&\000\025\'\000\026$\000\027&\000\030&\000\031\'\000\032$\000\033&\000\034%\000\035$\000\036&\000\037\'\000 &\000!&\000\"(\000";
    LCIMEnumDescriptor *worker =
        [LCIMEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AVIMOpType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AVIMOpType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AVIMOpType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AVIMOpType_Open:
    case AVIMOpType_Add:
    case AVIMOpType_Remove:
    case AVIMOpType_Close:
    case AVIMOpType_Opened:
    case AVIMOpType_Closed:
    case AVIMOpType_Query:
    case AVIMOpType_QueryResult:
    case AVIMOpType_Conflict:
    case AVIMOpType_Added:
    case AVIMOpType_Removed:
    case AVIMOpType_Start:
    case AVIMOpType_Started:
    case AVIMOpType_Joined:
    case AVIMOpType_MembersJoined:
    case AVIMOpType_Left:
    case AVIMOpType_MembersLeft:
    case AVIMOpType_Results:
    case AVIMOpType_Count:
    case AVIMOpType_Result:
    case AVIMOpType_Update:
    case AVIMOpType_Updated:
    case AVIMOpType_Mute:
    case AVIMOpType_Unmute:
    case AVIMOpType_Status:
    case AVIMOpType_Members:
    case AVIMOpType_Join:
    case AVIMOpType_Invite:
    case AVIMOpType_Leave:
    case AVIMOpType_Kick:
    case AVIMOpType_Reject:
    case AVIMOpType_Invited:
    case AVIMOpType_Kicked:
    case AVIMOpType_Upload:
    case AVIMOpType_Uploaded:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AVIMStatusType

LCIMEnumDescriptor *AVIMStatusType_EnumDescriptor(void) {
  static LCIMEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "On\000Off\000";
    static const int32_t values[] = {
        AVIMStatusType_On,
        AVIMStatusType_Off,
    };
    static const char *extraTextFormatInfo = "\002\000\"\000\001#\000";
    LCIMEnumDescriptor *worker =
        [LCIMEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AVIMStatusType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AVIMStatusType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AVIMStatusType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AVIMStatusType_On:
    case AVIMStatusType_Off:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AVIMJsonObjectMessage

@implementation AVIMJsonObjectMessage

@dynamic hasData_p, data_p;

typedef struct AVIMJsonObjectMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *data_p;
} AVIMJsonObjectMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMJsonObjectMessage_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMJsonObjectMessage__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMJsonObjectMessage class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMJsonObjectMessage__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMUnreadTuple

@implementation AVIMUnreadTuple

@dynamic hasCid, cid;
@dynamic hasUnread, unread;
@dynamic hasMid, mid;
@dynamic hasTimestamp, timestamp;

typedef struct AVIMUnreadTuple__storage_ {
  uint32_t _has_storage_[1];
  int32_t unread;
  NSString *cid;
  NSString *mid;
  int64_t timestamp;
} AVIMUnreadTuple__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, cid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unread",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Unread,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, unread),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMUnreadTuple class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMUnreadTuple__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMLogItem

@implementation AVIMLogItem

@dynamic hasFrom, from;
@dynamic hasData_p, data_p;
@dynamic hasTimestamp, timestamp;
@dynamic hasMsgId, msgId;
@dynamic hasAckAt, ackAt;

typedef struct AVIMLogItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *from;
  NSString *data_p;
  NSString *msgId;
  int64_t timestamp;
  int64_t ackAt;
} AVIMLogItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_From,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_MsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, msgId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ackAt",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_AckAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, ackAt),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMLogItem class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMLogItem__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\005\000\005\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMLoginCommand

@implementation AVIMLoginCommand


typedef struct AVIMLoginCommand__storage_ {
  uint32_t _has_storage_[1];
} AVIMLoginCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMLoginCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(AVIMLoginCommand__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMDataCommand

@implementation AVIMDataCommand

@dynamic idsArray, idsArray_Count;
@dynamic msgArray, msgArray_Count;
@dynamic hasOffline, offline;

typedef struct AVIMDataCommand__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idsArray;
  NSMutableArray *msgArray;
} AVIMDataCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDataCommand_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMDataCommand__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMDataCommand_FieldNumber_MsgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMDataCommand__storage_, msgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offline",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDataCommand_FieldNumber_Offline,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMDataCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMDataCommand__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMSessionCommand

@implementation AVIMSessionCommand

@dynamic hasT, t;
@dynamic hasN, n;
@dynamic hasS, s;
@dynamic hasUa, ua;
@dynamic hasR, r;
@dynamic hasTag, tag;
@dynamic hasDeviceId, deviceId;
@dynamic sessionPeerIdsArray, sessionPeerIdsArray_Count;
@dynamic onlineSessionPeerIdsArray, onlineSessionPeerIdsArray_Count;
@dynamic hasSt, st;
@dynamic hasStTtl, stTtl;
@dynamic hasCode, code;
@dynamic hasReason, reason;
@dynamic hasDeviceToken, deviceToken;
@dynamic hasSp, sp;
@dynamic hasDetail, detail;

typedef struct AVIMSessionCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t stTtl;
  int32_t code;
  NSString *n;
  NSString *s;
  NSString *ua;
  NSString *tag;
  NSString *deviceId;
  NSMutableArray *sessionPeerIdsArray;
  NSMutableArray *onlineSessionPeerIdsArray;
  NSString *st;
  NSString *reason;
  NSString *deviceToken;
  NSString *detail;
  int64_t t;
} AVIMSessionCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_T,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, t),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "n",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_N,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, n),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "s",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_S,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, s),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ua",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Ua,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, ua),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "r",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_R,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "tag",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Tag,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, tag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_DeviceId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, deviceId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionPeerIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_SessionPeerIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, sessionPeerIdsArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onlineSessionPeerIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_OnlineSessionPeerIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, onlineSessionPeerIdsArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "st",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_St,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, st),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stTtl",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_StTtl,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, stTtl),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Code,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Reason,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, reason),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceToken",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_DeviceToken,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, deviceToken),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Sp,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Detail,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMSessionCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMSessionCommand__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\007\010\000\010\000sessionPeerIds\000\t\000onlineSessionPeer"
        "Ids\000\013\005\000\016\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMErrorCommand

@implementation AVIMErrorCommand

@dynamic hasCode, code;
@dynamic hasReason, reason;
@dynamic hasAppCode, appCode;
@dynamic hasDetail, detail;

typedef struct AVIMErrorCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  int32_t appCode;
  NSString *reason;
  NSString *detail;
} AVIMErrorCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, code),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, reason),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appCode",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_AppCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, appCode),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_Detail,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMErrorCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMErrorCommand__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMDirectCommand

@implementation AVIMDirectCommand

@dynamic hasMsg, msg;
@dynamic hasUid, uid;
@dynamic hasFromPeerId, fromPeerId;
@dynamic hasTimestamp, timestamp;
@dynamic hasOffline, offline;
@dynamic hasHasMore, hasMore;
@dynamic toPeerIdsArray, toPeerIdsArray_Count;
@dynamic hasR, r;
@dynamic hasCid, cid;
@dynamic hasId_p, id_p;
@dynamic hasTransient, transient;
@dynamic hasDt, dt;
@dynamic hasRoomId, roomId;
@dynamic hasPushData, pushData;

typedef struct AVIMDirectCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
  NSString *uid;
  NSString *fromPeerId;
  NSMutableArray *toPeerIdsArray;
  NSString *cid;
  NSString *id_p;
  NSString *dt;
  NSString *roomId;
  NSString *pushData;
  int64_t timestamp;
} AVIMDirectCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Uid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromPeerId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_FromPeerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, fromPeerId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "offline",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Offline,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hasMore",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_HasMore,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "toPeerIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_ToPeerIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, toPeerIdsArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "r",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_R,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Cid,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Id_p,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transient",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Transient,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dt",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Dt,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, dt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_RoomId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, roomId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushData",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_PushData,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, pushData),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMDirectCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMDirectCommand__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\003\n\000\006\007\000\007\000toPeerIds\000\017\006\000\020\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMAckCommand

@implementation AVIMAckCommand

@dynamic hasCode, code;
@dynamic hasReason, reason;
@dynamic hasMid, mid;
@dynamic hasCid, cid;
@dynamic hasT, t;
@dynamic hasUid, uid;
@dynamic hasFromts, fromts;
@dynamic hasTots, tots;
@dynamic hasType, type;
@dynamic idsArray, idsArray_Count;
@dynamic hasAppCode, appCode;

typedef struct AVIMAckCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  int32_t appCode;
  NSString *reason;
  NSString *mid;
  NSString *cid;
  NSString *uid;
  NSString *type;
  NSMutableArray *idsArray;
  int64_t t;
  int64_t fromts;
  int64_t tots;
} AVIMAckCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, reason),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Cid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_T,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, t),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Uid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromts",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Fromts,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, fromts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tots",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Tots,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, tots),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Type,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appCode",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_AppCode,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, appCode),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMAckCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMAckCommand__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\013\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMUnreadCommand

@implementation AVIMUnreadCommand

@dynamic convsArray, convsArray_Count;

typedef struct AVIMUnreadCommand__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *convsArray;
} AVIMUnreadCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "convsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AVIMUnreadTuple),
        .number = AVIMUnreadCommand_FieldNumber_ConvsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMUnreadCommand__storage_, convsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMUnreadCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMUnreadCommand__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMConvCommand

@implementation AVIMConvCommand

@dynamic mArray, mArray_Count;
@dynamic hasTransient, transient;
@dynamic hasUnique, unique;
@dynamic hasCid, cid;
@dynamic hasCdate, cdate;
@dynamic hasInitBy, initBy;
@dynamic hasSort, sort;
@dynamic hasLimit, limit;
@dynamic hasSkip, skip;
@dynamic hasFlag, flag;
@dynamic hasCount, count;
@dynamic hasUdate, udate;
@dynamic hasT, t;
@dynamic hasN, n;
@dynamic hasS, s;
@dynamic hasStatusSub, statusSub;
@dynamic hasStatusPub, statusPub;
@dynamic hasStatusTtl, statusTtl;
@dynamic membersArray, membersArray_Count;
@dynamic hasResults, results;
@dynamic hasWhere, where;
@dynamic hasAttr, attr;

typedef struct AVIMConvCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  int32_t skip;
  int32_t flag;
  int32_t count;
  int32_t statusTtl;
  NSMutableArray *mArray;
  NSString *cid;
  NSString *cdate;
  NSString *initBy;
  NSString *sort;
  NSString *udate;
  NSString *n;
  NSString *s;
  NSMutableArray *membersArray;
  AVIMJsonObjectMessage *results;
  AVIMJsonObjectMessage *where;
  AVIMJsonObjectMessage *attr;
  int64_t t;
} AVIMConvCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_MArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, mArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transient",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Transient,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "unique",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Unique,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Cid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cdate",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Cdate,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, cdate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "initBy",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_InitBy,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, initBy),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sort",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Sort,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, sort),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Limit,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "skip",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Skip,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, skip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Flag,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, flag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Count,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "udate",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Udate,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, udate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_T,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, t),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "n",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_N,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, n),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "s",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_S,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, s),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "statusSub",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_StatusSub,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "statusPub",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_StatusPub,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "statusTtl",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_StatusTtl,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, statusTtl),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "results",
        .dataTypeSpecific.className = GPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMConvCommand_FieldNumber_Results,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, results),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "where",
        .dataTypeSpecific.className = GPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMConvCommand_FieldNumber_Where,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, where),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attr",
        .dataTypeSpecific.className = GPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMConvCommand_FieldNumber_Attr,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, attr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMConvCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMConvCommand__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\006\006\000\020\t\000\021\t\000\022\007b\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMRoomCommand

@implementation AVIMRoomCommand

@dynamic hasRoomId, roomId;
@dynamic hasS, s;
@dynamic hasT, t;
@dynamic hasN, n;
@dynamic hasTransient, transient;
@dynamic roomPeerIdsArray, roomPeerIdsArray_Count;
@dynamic hasByPeerId, byPeerId;

typedef struct AVIMRoomCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *roomId;
  NSString *s;
  NSString *n;
  NSMutableArray *roomPeerIdsArray;
  NSString *byPeerId;
  int64_t t;
} AVIMRoomCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, roomId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "s",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_S,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, s),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_T,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, t),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "n",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_N,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, n),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transient",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_Transient,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "roomPeerIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_RoomPeerIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, roomPeerIdsArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "byPeerId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_ByPeerId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, byPeerId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMRoomCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMRoomCommand__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\006\000roomPeerIds\000\007\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMLogsCommand

@implementation AVIMLogsCommand

@dynamic hasCid, cid;
@dynamic hasL, l;
@dynamic hasLimit, limit;
@dynamic hasT, t;
@dynamic hasTt, tt;
@dynamic hasTmid, tmid;
@dynamic hasMid, mid;
@dynamic hasChecksum, checksum;
@dynamic hasStored, stored;
@dynamic logsArray, logsArray_Count;

typedef struct AVIMLogsCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t l;
  int32_t limit;
  NSString *cid;
  NSString *tmid;
  NSString *mid;
  NSString *checksum;
  NSMutableArray *logsArray;
  int64_t t;
  int64_t tt;
} AVIMLogsCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogsCommand_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "l",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogsCommand_FieldNumber_L,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, l),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogsCommand_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogsCommand_FieldNumber_T,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, t),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tt",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogsCommand_FieldNumber_Tt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, tt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tmid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogsCommand_FieldNumber_Tmid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, tmid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogsCommand_FieldNumber_Mid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checksum",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogsCommand_FieldNumber_Checksum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, checksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stored",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogsCommand_FieldNumber_Stored,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "logsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AVIMLogItem),
        .number = AVIMLogsCommand_FieldNumber_LogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, logsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMLogsCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMLogsCommand__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMRcpCommand

@implementation AVIMRcpCommand

@dynamic hasId_p, id_p;
@dynamic hasCid, cid;
@dynamic hasT, t;

typedef struct AVIMRcpCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *cid;
  int64_t t;
} AVIMRcpCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRcpCommand_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMRcpCommand__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRcpCommand_FieldNumber_Cid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMRcpCommand__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRcpCommand_FieldNumber_T,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMRcpCommand__storage_, t),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMRcpCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMRcpCommand__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMReadTuple

@implementation AVIMReadTuple

@dynamic hasCid, cid;
@dynamic hasTimestamp, timestamp;
@dynamic hasMid, mid;

typedef struct AVIMReadTuple__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
  NSString *mid;
  int64_t timestamp;
} AVIMReadTuple__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadTuple_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMReadTuple__storage_, cid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadTuple_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMReadTuple__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadTuple_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMReadTuple__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMReadTuple class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMReadTuple__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMReadCommand

@implementation AVIMReadCommand

@dynamic hasCid, cid;
@dynamic cidsArray, cidsArray_Count;
@dynamic convsArray, convsArray_Count;

typedef struct AVIMReadCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
  NSMutableArray *cidsArray;
  NSMutableArray *convsArray;
} AVIMReadCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadCommand_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMReadCommand__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadCommand_FieldNumber_CidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMReadCommand__storage_, cidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "convsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AVIMReadTuple),
        .number = AVIMReadCommand_FieldNumber_ConvsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMReadCommand__storage_, convsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMReadCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMReadCommand__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMPresenceCommand

@implementation AVIMPresenceCommand

@dynamic hasStatus, status;
@dynamic sessionPeerIdsArray, sessionPeerIdsArray_Count;
@dynamic hasCid, cid;

typedef struct AVIMPresenceCommand__storage_ {
  uint32_t _has_storage_[1];
  AVIMStatusType status;
  NSMutableArray *sessionPeerIdsArray;
  NSString *cid;
} AVIMPresenceCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = AVIMStatusType_On,
        .core.name = "status",
        .core.dataTypeSpecific.enumDescFunc = AVIMStatusType_EnumDescriptor,
        .core.number = AVIMPresenceCommand_FieldNumber_Status,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(AVIMPresenceCommand__storage_, status),
        .core.flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "sessionPeerIdsArray",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMPresenceCommand_FieldNumber_SessionPeerIdsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(AVIMPresenceCommand__storage_, sessionPeerIdsArray),
        .core.flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "cid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMPresenceCommand_FieldNumber_Cid,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(AVIMPresenceCommand__storage_, cid),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMPresenceCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(AVIMPresenceCommand__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000sessionPeerIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMReportCommand

@implementation AVIMReportCommand

@dynamic hasInitiative, initiative;
@dynamic hasType, type;
@dynamic hasData_p, data_p;

typedef struct AVIMReportCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSString *data_p;
} AVIMReportCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "initiative",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReportCommand_FieldNumber_Initiative,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReportCommand_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMReportCommand__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReportCommand_FieldNumber_Data_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMReportCommand__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMReportCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMReportCommand__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMGenericCommand

@implementation AVIMGenericCommand

@dynamic hasCmd, cmd;
@dynamic hasOp, op;
@dynamic hasAppId, appId;
@dynamic hasPeerId, peerId;
@dynamic hasI, i;
@dynamic hasInstallationId, installationId;
@dynamic hasPriority, priority;
@dynamic hasLoginMessage, loginMessage;
@dynamic hasDataMessage, dataMessage;
@dynamic hasSessionMessage, sessionMessage;
@dynamic hasErrorMessage, errorMessage;
@dynamic hasDirectMessage, directMessage;
@dynamic hasAckMessage, ackMessage;
@dynamic hasUnreadMessage, unreadMessage;
@dynamic hasReadMessage, readMessage;
@dynamic hasRcpMessage, rcpMessage;
@dynamic hasLogsMessage, logsMessage;
@dynamic hasConvMessage, convMessage;
@dynamic hasRoomMessage, roomMessage;
@dynamic hasPresenceMessage, presenceMessage;
@dynamic hasReportMessage, reportMessage;

typedef struct AVIMGenericCommand__storage_ {
  uint32_t _has_storage_[1];
  AVIMCommandType cmd;
  AVIMOpType op;
  int32_t i;
  int32_t priority;
  NSString *appId;
  NSString *peerId;
  NSString *installationId;
  AVIMLoginCommand *loginMessage;
  AVIMDataCommand *dataMessage;
  AVIMSessionCommand *sessionMessage;
  AVIMErrorCommand *errorMessage;
  AVIMDirectCommand *directMessage;
  AVIMAckCommand *ackMessage;
  AVIMUnreadCommand *unreadMessage;
  AVIMReadCommand *readMessage;
  AVIMRcpCommand *rcpMessage;
  AVIMLogsCommand *logsMessage;
  AVIMConvCommand *convMessage;
  AVIMRoomCommand *roomMessage;
  AVIMPresenceCommand *presenceMessage;
  AVIMReportCommand *reportMessage;
} AVIMGenericCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = AVIMCommandType_Session,
        .core.name = "cmd",
        .core.dataTypeSpecific.enumDescFunc = AVIMCommandType_EnumDescriptor,
        .core.number = AVIMGenericCommand_FieldNumber_Cmd,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, cmd),
        .core.flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = AVIMOpType_Open,
        .core.name = "op",
        .core.dataTypeSpecific.enumDescFunc = AVIMOpType_EnumDescriptor,
        .core.number = AVIMGenericCommand_FieldNumber_Op,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, op),
        .core.flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "appId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_AppId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, appId),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "peerId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_PeerId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, peerId),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "i",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_I,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, i),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "installationId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_InstallationId,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, installationId),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "priority",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_Priority,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, priority),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "loginMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMLoginCommand),
        .core.number = AVIMGenericCommand_FieldNumber_LoginMessage,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, loginMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "dataMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMDataCommand),
        .core.number = AVIMGenericCommand_FieldNumber_DataMessage,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, dataMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "sessionMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMSessionCommand),
        .core.number = AVIMGenericCommand_FieldNumber_SessionMessage,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, sessionMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "errorMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMErrorCommand),
        .core.number = AVIMGenericCommand_FieldNumber_ErrorMessage,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, errorMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "directMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMDirectCommand),
        .core.number = AVIMGenericCommand_FieldNumber_DirectMessage,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, directMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "ackMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMAckCommand),
        .core.number = AVIMGenericCommand_FieldNumber_AckMessage,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, ackMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "unreadMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMUnreadCommand),
        .core.number = AVIMGenericCommand_FieldNumber_UnreadMessage,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, unreadMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "readMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMReadCommand),
        .core.number = AVIMGenericCommand_FieldNumber_ReadMessage,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, readMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rcpMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMRcpCommand),
        .core.number = AVIMGenericCommand_FieldNumber_RcpMessage,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, rcpMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "logsMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMLogsCommand),
        .core.number = AVIMGenericCommand_FieldNumber_LogsMessage,
        .core.hasIndex = 16,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, logsMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "convMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMConvCommand),
        .core.number = AVIMGenericCommand_FieldNumber_ConvMessage,
        .core.hasIndex = 17,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, convMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "roomMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMRoomCommand),
        .core.number = AVIMGenericCommand_FieldNumber_RoomMessage,
        .core.hasIndex = 18,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, roomMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "presenceMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMPresenceCommand),
        .core.number = AVIMGenericCommand_FieldNumber_PresenceMessage,
        .core.hasIndex = 19,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, presenceMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "reportMessage",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AVIMReportCommand),
        .core.number = AVIMGenericCommand_FieldNumber_ReportMessage,
        .core.hasIndex = 20,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, reportMessage),
        .core.flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[AVIMGenericCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(AVIMGenericCommand__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\021\003\005\000\004\006\000\006\016\000d\014\000e\013\000f\016\000g\014\000h\r\000i\n\000j\r\000k\013\000l\n\000m\013\000"
        "n\013\000o\013\000p\017\000q\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
