// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto.orig

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(LCGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define LCGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if LCGPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/LCGPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "LCGPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "MessagesProtoOrig.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - AVIMMessagesProtoOrigRoot

@implementation AVIMMessagesProtoOrigRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - AVIMMessagesProtoOrigRoot_FileDescriptor

static LCGPBFileDescriptor *AVIMMessagesProtoOrigRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static LCGPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    LCGPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[LCGPBFileDescriptor alloc] initWithPackage:@"push_server.messages2"
                                                 objcPrefix:@"AVIM"
                                                     syntax:LCGPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum AVIMCommandType

LCGPBEnumDescriptor *AVIMCommandType_EnumDescriptor(void) {
  static _Atomic(LCGPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Session\000Conv\000Direct\000Ack\000Rcp\000Unread\000Logs\000"
        "Error\000Login\000Data\000Room\000Read\000Presence\000Repo"
        "rt\000Echo\000Loggedin\000Logout\000Loggedout\000Patch\000"
        "Pubsub\000Blacklist\000Goaway\000";
    static const int32_t values[] = {
        AVIMCommandType_Session,
        AVIMCommandType_Conv,
        AVIMCommandType_Direct,
        AVIMCommandType_Ack,
        AVIMCommandType_Rcp,
        AVIMCommandType_Unread,
        AVIMCommandType_Logs,
        AVIMCommandType_Error,
        AVIMCommandType_Login,
        AVIMCommandType_Data,
        AVIMCommandType_Room,
        AVIMCommandType_Read,
        AVIMCommandType_Presence,
        AVIMCommandType_Report,
        AVIMCommandType_Echo,
        AVIMCommandType_Loggedin,
        AVIMCommandType_Logout,
        AVIMCommandType_Loggedout,
        AVIMCommandType_Patch,
        AVIMCommandType_Pubsub,
        AVIMCommandType_Blacklist,
        AVIMCommandType_Goaway,
    };
    static const char *extraTextFormatInfo = "\026\000\'\000\001$\000\002&\000\003#\000\004#\000\005&\000\006$\000\007%\000\010%\000\t$\000\n$\000\013$\000\014(\000\r&\000\016$\000\017(\000\020&\000\021)\000\022%\000\023&\000\024)\000\025&\000";
    LCGPBEnumDescriptor *worker =
        [LCGPBEnumDescriptor allocDescriptorForName:LCGPBNSStringifySymbol(AVIMCommandType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AVIMCommandType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    LCGPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AVIMCommandType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AVIMCommandType_Session:
    case AVIMCommandType_Conv:
    case AVIMCommandType_Direct:
    case AVIMCommandType_Ack:
    case AVIMCommandType_Rcp:
    case AVIMCommandType_Unread:
    case AVIMCommandType_Logs:
    case AVIMCommandType_Error:
    case AVIMCommandType_Login:
    case AVIMCommandType_Data:
    case AVIMCommandType_Room:
    case AVIMCommandType_Read:
    case AVIMCommandType_Presence:
    case AVIMCommandType_Report:
    case AVIMCommandType_Echo:
    case AVIMCommandType_Loggedin:
    case AVIMCommandType_Logout:
    case AVIMCommandType_Loggedout:
    case AVIMCommandType_Patch:
    case AVIMCommandType_Pubsub:
    case AVIMCommandType_Blacklist:
    case AVIMCommandType_Goaway:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AVIMOpType

LCGPBEnumDescriptor *AVIMOpType_EnumDescriptor(void) {
  static _Atomic(LCGPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Open\000Add\000Remove\000Close\000Opened\000Closed\000Quer"
        "y\000QueryResult\000Conflict\000Added\000Removed\000Ref"
        "resh\000Refreshed\000Start\000Started\000Joined\000Memb"
        "ersJoined\000Left\000MembersLeft\000Results\000Count"
        "\000Result\000Update\000Updated\000Mute\000Unmute\000Statu"
        "s\000Members\000MaxRead\000IsMember\000MemberInfoUpd"
        "ate\000MemberInfoUpdated\000MemberInfoChanged\000"
        "Join\000Invite\000Leave\000Kick\000Reject\000Invited\000Ki"
        "cked\000Upload\000Uploaded\000Subscribe\000Subscribe"
        "d\000Unsubscribe\000Unsubscribed\000IsSubscribed\000"
        "Modify\000Modified\000Block\000Unblock\000Blocked\000Un"
        "blocked\000MembersBlocked\000MembersUnblocked\000"
        "CheckBlock\000CheckResult\000AddShutup\000RemoveS"
        "hutup\000QueryShutup\000ShutupAdded\000ShutupRemo"
        "ved\000ShutupResult\000Shutuped\000Unshutuped\000Mem"
        "bersShutuped\000MembersUnshutuped\000CheckShut"
        "up\000";
    static const int32_t values[] = {
        AVIMOpType_Open,
        AVIMOpType_Add,
        AVIMOpType_Remove,
        AVIMOpType_Close,
        AVIMOpType_Opened,
        AVIMOpType_Closed,
        AVIMOpType_Query,
        AVIMOpType_QueryResult,
        AVIMOpType_Conflict,
        AVIMOpType_Added,
        AVIMOpType_Removed,
        AVIMOpType_Refresh,
        AVIMOpType_Refreshed,
        AVIMOpType_Start,
        AVIMOpType_Started,
        AVIMOpType_Joined,
        AVIMOpType_MembersJoined,
        AVIMOpType_Left,
        AVIMOpType_MembersLeft,
        AVIMOpType_Results,
        AVIMOpType_Count,
        AVIMOpType_Result,
        AVIMOpType_Update,
        AVIMOpType_Updated,
        AVIMOpType_Mute,
        AVIMOpType_Unmute,
        AVIMOpType_Status,
        AVIMOpType_Members,
        AVIMOpType_MaxRead,
        AVIMOpType_IsMember,
        AVIMOpType_MemberInfoUpdate,
        AVIMOpType_MemberInfoUpdated,
        AVIMOpType_MemberInfoChanged,
        AVIMOpType_Join,
        AVIMOpType_Invite,
        AVIMOpType_Leave,
        AVIMOpType_Kick,
        AVIMOpType_Reject,
        AVIMOpType_Invited,
        AVIMOpType_Kicked,
        AVIMOpType_Upload,
        AVIMOpType_Uploaded,
        AVIMOpType_Subscribe,
        AVIMOpType_Subscribed,
        AVIMOpType_Unsubscribe,
        AVIMOpType_Unsubscribed,
        AVIMOpType_IsSubscribed,
        AVIMOpType_Modify,
        AVIMOpType_Modified,
        AVIMOpType_Block,
        AVIMOpType_Unblock,
        AVIMOpType_Blocked,
        AVIMOpType_Unblocked,
        AVIMOpType_MembersBlocked,
        AVIMOpType_MembersUnblocked,
        AVIMOpType_CheckBlock,
        AVIMOpType_CheckResult,
        AVIMOpType_AddShutup,
        AVIMOpType_RemoveShutup,
        AVIMOpType_QueryShutup,
        AVIMOpType_ShutupAdded,
        AVIMOpType_ShutupRemoved,
        AVIMOpType_ShutupResult,
        AVIMOpType_Shutuped,
        AVIMOpType_Unshutuped,
        AVIMOpType_MembersShutuped,
        AVIMOpType_MembersUnshutuped,
        AVIMOpType_CheckShutup,
    };
    static const char *extraTextFormatInfo = "D\000$\000\001#\000\002&\000\003%\000\004&\000\005&\000\006%\000\007%\246\000\010(\000\t%\000\n\'\000\013\'\000\014)\000\r%\000\016\'\000\017&\000\020\'\246\000\021$\000\022\'\244\000\023\'\000\024%\000\025&\000\026&\000\027\'\000\030$\000\031&\000\032&\000\033\'\000\034#\244\000\035\"\246\000\036&\244\246\000\037&\244\247\000 &\244\247\000!$\000\"&\000#%\000$$\000%&\000&\'\000\'&\000(&\000)(\000*)\000+*\000,+\000-,\000.\"\252\000/&\0000(\0001%\0002\'\0003\'\0004)\0005\'\247\0006\'\251\0007%\245\0008%\246\0009#\246\000:&\246\000;%\246\000<&\245\000=&\247\000>&\246\000?(\000@*\000A\'\250\000B\'\252\000C%\246\000";
    LCGPBEnumDescriptor *worker =
        [LCGPBEnumDescriptor allocDescriptorForName:LCGPBNSStringifySymbol(AVIMOpType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AVIMOpType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    LCGPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AVIMOpType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AVIMOpType_Open:
    case AVIMOpType_Add:
    case AVIMOpType_Remove:
    case AVIMOpType_Close:
    case AVIMOpType_Opened:
    case AVIMOpType_Closed:
    case AVIMOpType_Query:
    case AVIMOpType_QueryResult:
    case AVIMOpType_Conflict:
    case AVIMOpType_Added:
    case AVIMOpType_Removed:
    case AVIMOpType_Refresh:
    case AVIMOpType_Refreshed:
    case AVIMOpType_Start:
    case AVIMOpType_Started:
    case AVIMOpType_Joined:
    case AVIMOpType_MembersJoined:
    case AVIMOpType_Left:
    case AVIMOpType_MembersLeft:
    case AVIMOpType_Results:
    case AVIMOpType_Count:
    case AVIMOpType_Result:
    case AVIMOpType_Update:
    case AVIMOpType_Updated:
    case AVIMOpType_Mute:
    case AVIMOpType_Unmute:
    case AVIMOpType_Status:
    case AVIMOpType_Members:
    case AVIMOpType_MaxRead:
    case AVIMOpType_IsMember:
    case AVIMOpType_MemberInfoUpdate:
    case AVIMOpType_MemberInfoUpdated:
    case AVIMOpType_MemberInfoChanged:
    case AVIMOpType_Join:
    case AVIMOpType_Invite:
    case AVIMOpType_Leave:
    case AVIMOpType_Kick:
    case AVIMOpType_Reject:
    case AVIMOpType_Invited:
    case AVIMOpType_Kicked:
    case AVIMOpType_Upload:
    case AVIMOpType_Uploaded:
    case AVIMOpType_Subscribe:
    case AVIMOpType_Subscribed:
    case AVIMOpType_Unsubscribe:
    case AVIMOpType_Unsubscribed:
    case AVIMOpType_IsSubscribed:
    case AVIMOpType_Modify:
    case AVIMOpType_Modified:
    case AVIMOpType_Block:
    case AVIMOpType_Unblock:
    case AVIMOpType_Blocked:
    case AVIMOpType_Unblocked:
    case AVIMOpType_MembersBlocked:
    case AVIMOpType_MembersUnblocked:
    case AVIMOpType_CheckBlock:
    case AVIMOpType_CheckResult:
    case AVIMOpType_AddShutup:
    case AVIMOpType_RemoveShutup:
    case AVIMOpType_QueryShutup:
    case AVIMOpType_ShutupAdded:
    case AVIMOpType_ShutupRemoved:
    case AVIMOpType_ShutupResult:
    case AVIMOpType_Shutuped:
    case AVIMOpType_Unshutuped:
    case AVIMOpType_MembersShutuped:
    case AVIMOpType_MembersUnshutuped:
    case AVIMOpType_CheckShutup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AVIMStatusType

LCGPBEnumDescriptor *AVIMStatusType_EnumDescriptor(void) {
  static _Atomic(LCGPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "On\000Off\000";
    static const int32_t values[] = {
        AVIMStatusType_On,
        AVIMStatusType_Off,
    };
    static const char *extraTextFormatInfo = "\002\000\"\000\001#\000";
    LCGPBEnumDescriptor *worker =
        [LCGPBEnumDescriptor allocDescriptorForName:LCGPBNSStringifySymbol(AVIMStatusType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AVIMStatusType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    LCGPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AVIMStatusType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AVIMStatusType_On:
    case AVIMStatusType_Off:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AVIMJsonObjectMessage

@implementation AVIMJsonObjectMessage

@dynamic hasData_p, data_p;

typedef struct AVIMJsonObjectMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *data_p;
} AVIMJsonObjectMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMJsonObjectMessage_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMJsonObjectMessage__storage_, data_p),
        .flags = LCGPBFieldRequired,
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMJsonObjectMessage class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMJsonObjectMessage__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMUnreadTuple

@implementation AVIMUnreadTuple

@dynamic hasCid, cid;
@dynamic hasUnread, unread;
@dynamic hasMid, mid;
@dynamic hasTimestamp, timestamp;
@dynamic hasFrom, from;
@dynamic hasData_p, data_p;
@dynamic hasPatchTimestamp, patchTimestamp;
@dynamic hasMentioned, mentioned;
@dynamic hasBinaryMsg, binaryMsg;
@dynamic hasConvType, convType;

typedef struct AVIMUnreadTuple__storage_ {
  uint32_t _has_storage_[1];
  int32_t unread;
  int32_t convType;
  NSString *cid;
  NSString *mid;
  NSString *from;
  NSString *data_p;
  NSData *binaryMsg;
  int64_t timestamp;
  int64_t patchTimestamp;
} AVIMUnreadTuple__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, cid),
        .flags = LCGPBFieldRequired,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "unread",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Unread,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, unread),
        .flags = LCGPBFieldRequired,
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, mid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, timestamp),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_From,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, from),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Data_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, data_p),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "patchTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_PatchTimestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, patchTimestamp),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "mentioned",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_Mentioned,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "binaryMsg",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_BinaryMsg,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, binaryMsg),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBytes,
      },
      {
        .name = "convType",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadTuple_FieldNumber_ConvType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AVIMUnreadTuple__storage_, convType),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt32,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMUnreadTuple class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMUnreadTuple__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\007\016\000\t\t\000\n\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMLogItem

@implementation AVIMLogItem

@dynamic hasFrom, from;
@dynamic hasData_p, data_p;
@dynamic hasTimestamp, timestamp;
@dynamic hasMsgId, msgId;
@dynamic hasAckAt, ackAt;
@dynamic hasReadAt, readAt;
@dynamic hasPatchTimestamp, patchTimestamp;
@dynamic hasMentionAll, mentionAll;
@dynamic mentionPidsArray, mentionPidsArray_Count;
@dynamic hasBin, bin;
@dynamic hasConvType, convType;

typedef struct AVIMLogItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t convType;
  NSString *from;
  NSString *data_p;
  NSString *msgId;
  NSMutableArray *mentionPidsArray;
  int64_t timestamp;
  int64_t ackAt;
  int64_t readAt;
  int64_t patchTimestamp;
} AVIMLogItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_From,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, from),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, data_p),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, timestamp),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_MsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, msgId),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "ackAt",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_AckAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, ackAt),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "readAt",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_ReadAt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, readAt),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "patchTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_PatchTimestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, patchTimestamp),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "mentionAll",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_MentionAll,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "mentionPidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_MentionPidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, mentionPidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "bin",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_Bin,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "convType",
        .dataTypeSpecific.className = NULL,
        .number = AVIMLogItem_FieldNumber_ConvType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AVIMLogItem__storage_, convType),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt32,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMLogItem class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMLogItem__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\004\005\000\005\005\000\006\006\000\007\016\000\010\n\000\t\000mentionPids\000\013\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMConvMemberInfo

@implementation AVIMConvMemberInfo

@dynamic hasPid, pid;
@dynamic hasRole, role;
@dynamic hasInfoId, infoId;

typedef struct AVIMConvMemberInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *pid;
  NSString *role;
  NSString *infoId;
} AVIMConvMemberInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "pid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvMemberInfo_FieldNumber_Pid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMConvMemberInfo__storage_, pid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "role",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvMemberInfo_FieldNumber_Role,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMConvMemberInfo__storage_, role),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "infoId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvMemberInfo_FieldNumber_InfoId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMConvMemberInfo__storage_, infoId),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMConvMemberInfo class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMConvMemberInfo__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMDataCommand

@implementation AVIMDataCommand

@dynamic idsArray, idsArray_Count;
@dynamic msgArray, msgArray_Count;
@dynamic hasOffline, offline;

typedef struct AVIMDataCommand__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idsArray;
  NSMutableArray *msgArray;
} AVIMDataCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDataCommand_FieldNumber_IdsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMDataCommand__storage_, idsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "msgArray",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMDataCommand_FieldNumber_MsgArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMDataCommand__storage_, msgArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "offline",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDataCommand_FieldNumber_Offline,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMDataCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMDataCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMSessionCommand

@implementation AVIMSessionCommand

@dynamic hasT, t;
@dynamic hasN, n;
@dynamic hasS, s;
@dynamic hasUa, ua;
@dynamic hasR, r;
@dynamic hasTag, tag;
@dynamic hasDeviceId, deviceId;
@dynamic sessionPeerIdsArray, sessionPeerIdsArray_Count;
@dynamic onlineSessionPeerIdsArray, onlineSessionPeerIdsArray_Count;
@dynamic hasSt, st;
@dynamic hasStTtl, stTtl;
@dynamic hasCode, code;
@dynamic hasReason, reason;
@dynamic hasDeviceToken, deviceToken;
@dynamic hasSp, sp;
@dynamic hasDetail, detail;
@dynamic hasLastUnreadNotifTime, lastUnreadNotifTime;
@dynamic hasLastPatchTime, lastPatchTime;
@dynamic hasConfigBitmap, configBitmap;

typedef struct AVIMSessionCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t stTtl;
  int32_t code;
  NSString *n;
  NSString *s;
  NSString *ua;
  NSString *tag;
  NSString *deviceId;
  NSMutableArray *sessionPeerIdsArray;
  NSMutableArray *onlineSessionPeerIdsArray;
  NSString *st;
  NSString *reason;
  NSString *deviceToken;
  NSString *detail;
  int64_t t;
  int64_t lastUnreadNotifTime;
  int64_t lastPatchTime;
  int64_t configBitmap;
} AVIMSessionCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_T,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, t),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "n",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_N,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, n),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "s",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_S,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, s),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "ua",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Ua,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, ua),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "r",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_R,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "tag",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Tag,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, tag),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_DeviceId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, deviceId),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "sessionPeerIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_SessionPeerIdsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, sessionPeerIdsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "onlineSessionPeerIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_OnlineSessionPeerIdsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, onlineSessionPeerIdsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "st",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_St,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, st),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "stTtl",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_StTtl,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, stTtl),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Code,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, code),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Reason,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, reason),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "deviceToken",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_DeviceToken,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, deviceToken),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "sp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Sp,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_Detail,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, detail),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "lastUnreadNotifTime",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_LastUnreadNotifTime,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, lastUnreadNotifTime),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "lastPatchTime",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_LastPatchTime,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, lastPatchTime),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "configBitmap",
        .dataTypeSpecific.className = NULL,
        .number = AVIMSessionCommand_FieldNumber_ConfigBitmap,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(AVIMSessionCommand__storage_, configBitmap),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMSessionCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMSessionCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\007\010\000\010\000sessionPeerIds\000\t\000onlineSessionPeer"
        "Ids\000\013\005\000\016\013\000\021\023\000\022\r\000\023\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMErrorCommand

@implementation AVIMErrorCommand

@dynamic hasCode, code;
@dynamic hasReason, reason;
@dynamic hasAppCode, appCode;
@dynamic hasDetail, detail;
@dynamic pidsArray, pidsArray_Count;
@dynamic hasAppMsg, appMsg;

typedef struct AVIMErrorCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  int32_t appCode;
  NSString *reason;
  NSString *detail;
  NSMutableArray *pidsArray;
  NSString *appMsg;
} AVIMErrorCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, code),
        .flags = LCGPBFieldRequired,
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, reason),
        .flags = LCGPBFieldRequired,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "appCode",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_AppCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, appCode),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_Detail,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, detail),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "pidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_PidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, pidsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "appMsg",
        .dataTypeSpecific.className = NULL,
        .number = AVIMErrorCommand_FieldNumber_AppMsg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMErrorCommand__storage_, appMsg),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMErrorCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMErrorCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\007\000\006\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMDirectCommand

@implementation AVIMDirectCommand

@dynamic hasMsg, msg;
@dynamic hasUid, uid;
@dynamic hasFromPeerId, fromPeerId;
@dynamic hasTimestamp, timestamp;
@dynamic hasOffline, offline;
@dynamic hasHasMore, hasMore;
@dynamic toPeerIdsArray, toPeerIdsArray_Count;
@dynamic hasR, r;
@dynamic hasCid, cid;
@dynamic hasId_p, id_p;
@dynamic hasTransient, transient;
@dynamic hasDt, dt;
@dynamic hasRoomId, roomId;
@dynamic hasPushData, pushData;
@dynamic hasWill, will;
@dynamic hasPatchTimestamp, patchTimestamp;
@dynamic hasBinaryMsg, binaryMsg;
@dynamic mentionPidsArray, mentionPidsArray_Count;
@dynamic hasMentionAll, mentionAll;
@dynamic hasConvType, convType;

typedef struct AVIMDirectCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t convType;
  NSString *msg;
  NSString *uid;
  NSString *fromPeerId;
  NSMutableArray *toPeerIdsArray;
  NSString *cid;
  NSString *id_p;
  NSString *dt;
  NSString *roomId;
  NSString *pushData;
  NSData *binaryMsg;
  NSMutableArray *mentionPidsArray;
  int64_t timestamp;
  int64_t patchTimestamp;
} AVIMDirectCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, msg),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Uid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, uid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "fromPeerId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_FromPeerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, fromPeerId),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, timestamp),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "offline",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Offline,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "hasMore",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_HasMore,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "toPeerIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_ToPeerIdsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, toPeerIdsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "r",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_R,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Cid,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, cid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Id_p,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, id_p),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "transient",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Transient,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "dt",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Dt,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, dt),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_RoomId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, roomId),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "pushData",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_PushData,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, pushData),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "will",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_Will,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "patchTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_PatchTimestamp,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, patchTimestamp),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "binaryMsg",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_BinaryMsg,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, binaryMsg),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBytes,
      },
      {
        .name = "mentionPidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_MentionPidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, mentionPidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "mentionAll",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_MentionAll,
        .hasIndex = 21,
        .offset = 22,  // Stored in _has_storage_ to save space.
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "convType",
        .dataTypeSpecific.className = NULL,
        .number = AVIMDirectCommand_FieldNumber_ConvType,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(AVIMDirectCommand__storage_, convType),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt32,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMDirectCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMDirectCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\003\n\000\006\007\000\007\000toPeerIds\000\017\006\000\020\010\000\022\016\000\023\t\000\024\000mention"
        "Pids\000\025\n\000\026\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMAckCommand

@implementation AVIMAckCommand

@dynamic hasCode, code;
@dynamic hasReason, reason;
@dynamic hasMid, mid;
@dynamic hasCid, cid;
@dynamic hasT, t;
@dynamic hasUid, uid;
@dynamic hasFromts, fromts;
@dynamic hasTots, tots;
@dynamic hasType, type;
@dynamic idsArray, idsArray_Count;
@dynamic hasAppCode, appCode;
@dynamic hasAppMsg, appMsg;

typedef struct AVIMAckCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  int32_t appCode;
  NSString *reason;
  NSString *mid;
  NSString *cid;
  NSString *uid;
  NSString *type;
  NSMutableArray *idsArray;
  NSString *appMsg;
  int64_t t;
  int64_t fromts;
  int64_t tots;
} AVIMAckCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, code),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, reason),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, mid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Cid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, cid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_T,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, t),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Uid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, uid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "fromts",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Fromts,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, fromts),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "tots",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Tots,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, tots),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_Type,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, type),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_IdsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, idsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "appCode",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_AppCode,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, appCode),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "appMsg",
        .dataTypeSpecific.className = NULL,
        .number = AVIMAckCommand_FieldNumber_AppMsg,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AVIMAckCommand__storage_, appMsg),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMAckCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMAckCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\013\007\000\014\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMUnreadCommand

@implementation AVIMUnreadCommand

@dynamic convsArray, convsArray_Count;
@dynamic hasNotifTime, notifTime;

typedef struct AVIMUnreadCommand__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *convsArray;
  int64_t notifTime;
} AVIMUnreadCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "convsArray",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMUnreadTuple),
        .number = AVIMUnreadCommand_FieldNumber_ConvsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMUnreadCommand__storage_, convsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "notifTime",
        .dataTypeSpecific.className = NULL,
        .number = AVIMUnreadCommand_FieldNumber_NotifTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMUnreadCommand__storage_, notifTime),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMUnreadCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMUnreadCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMConvCommand

@implementation AVIMConvCommand

@dynamic mArray, mArray_Count;
@dynamic hasTransient, transient;
@dynamic hasUnique, unique;
@dynamic hasCid, cid;
@dynamic hasCdate, cdate;
@dynamic hasInitBy, initBy;
@dynamic hasSort, sort;
@dynamic hasLimit, limit;
@dynamic hasSkip, skip;
@dynamic hasFlag, flag;
@dynamic hasCount, count;
@dynamic hasUdate, udate;
@dynamic hasT, t;
@dynamic hasN, n;
@dynamic hasS, s;
@dynamic hasStatusSub, statusSub;
@dynamic hasStatusPub, statusPub;
@dynamic hasStatusTtl, statusTtl;
@dynamic hasUniqueId, uniqueId;
@dynamic hasTargetClientId, targetClientId;
@dynamic hasMaxReadTimestamp, maxReadTimestamp;
@dynamic hasMaxAckTimestamp, maxAckTimestamp;
@dynamic hasQueryAllMembers, queryAllMembers;
@dynamic maxReadTuplesArray, maxReadTuplesArray_Count;
@dynamic cidsArray, cidsArray_Count;
@dynamic hasInfo, info;
@dynamic hasTempConv, tempConv;
@dynamic hasTempConvTtl, tempConvTtl;
@dynamic tempConvIdsArray, tempConvIdsArray_Count;
@dynamic allowedPidsArray, allowedPidsArray_Count;
@dynamic failedPidsArray, failedPidsArray_Count;
@dynamic hasNext, next;
@dynamic hasResults, results;
@dynamic hasWhere, where;
@dynamic hasAttr, attr;
@dynamic hasAttrModified, attrModified;

typedef struct AVIMConvCommand__storage_ {
  uint32_t _has_storage_[2];
  int32_t limit;
  int32_t skip;
  int32_t flag;
  int32_t count;
  int32_t statusTtl;
  int32_t tempConvTtl;
  NSMutableArray *mArray;
  NSString *cid;
  NSString *cdate;
  NSString *initBy;
  NSString *sort;
  NSString *udate;
  NSString *n;
  NSString *s;
  NSString *uniqueId;
  NSString *targetClientId;
  NSMutableArray *maxReadTuplesArray;
  NSMutableArray *cidsArray;
  AVIMConvMemberInfo *info;
  NSMutableArray *tempConvIdsArray;
  NSMutableArray *allowedPidsArray;
  NSMutableArray *failedPidsArray;
  NSString *next;
  AVIMJsonObjectMessage *results;
  AVIMJsonObjectMessage *where;
  AVIMJsonObjectMessage *attr;
  AVIMJsonObjectMessage *attrModified;
  int64_t t;
  int64_t maxReadTimestamp;
  int64_t maxAckTimestamp;
} AVIMConvCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "mArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_MArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, mArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "transient",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Transient,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "unique",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Unique,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Cid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, cid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "cdate",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Cdate,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, cdate),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "initBy",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_InitBy,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, initBy),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "sort",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Sort,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, sort),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Limit,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, limit),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "skip",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Skip,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, skip),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Flag,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, flag),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Count,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, count),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "udate",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Udate,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, udate),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_T,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, t),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "n",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_N,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, n),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "s",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_S,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, s),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "statusSub",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_StatusSub,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "statusPub",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_StatusPub,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "statusTtl",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_StatusTtl,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, statusTtl),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "uniqueId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_UniqueId,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, uniqueId),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "targetClientId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_TargetClientId,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, targetClientId),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "maxReadTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_MaxReadTimestamp,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, maxReadTimestamp),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "maxAckTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_MaxAckTimestamp,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, maxAckTimestamp),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "queryAllMembers",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_QueryAllMembers,
        .hasIndex = 25,
        .offset = 26,  // Stored in _has_storage_ to save space.
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "maxReadTuplesArray",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMMaxReadTuple),
        .number = AVIMConvCommand_FieldNumber_MaxReadTuplesArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, maxReadTuplesArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_CidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, cidsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "info",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMConvMemberInfo),
        .number = AVIMConvCommand_FieldNumber_Info,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, info),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "tempConv",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_TempConv,
        .hasIndex = 28,
        .offset = 29,  // Stored in _has_storage_ to save space.
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "tempConvTtl",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_TempConvTtl,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, tempConvTtl),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "tempConvIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_TempConvIdsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, tempConvIdsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "allowedPidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_AllowedPidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, allowedPidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "failedPidsArray",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMErrorCommand),
        .number = AVIMConvCommand_FieldNumber_FailedPidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, failedPidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "next",
        .dataTypeSpecific.className = NULL,
        .number = AVIMConvCommand_FieldNumber_Next,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, next),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "results",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMConvCommand_FieldNumber_Results,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, results),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "where",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMConvCommand_FieldNumber_Where,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, where),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "attr",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMConvCommand_FieldNumber_Attr,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, attr),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "attrModified",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMConvCommand_FieldNumber_AttrModified,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(AVIMConvCommand__storage_, attrModified),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeMessage,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMConvCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMConvCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\020\006\006\000\020\t\000\021\t\000\022\007b\000\023\010\000\024\016\000\025\020\000\026\017\000\027\017\000\030\000maxReadTu"
        "ples\000\033\010\000\034\tb\000\035\000tempConvIds\000\036\000allowedPids\000"
        "\037\000failedPids\000h\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMRoomCommand

@implementation AVIMRoomCommand

@dynamic hasRoomId, roomId;
@dynamic hasS, s;
@dynamic hasT, t;
@dynamic hasN, n;
@dynamic hasTransient, transient;
@dynamic roomPeerIdsArray, roomPeerIdsArray_Count;
@dynamic hasByPeerId, byPeerId;

typedef struct AVIMRoomCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *roomId;
  NSString *s;
  NSString *n;
  NSMutableArray *roomPeerIdsArray;
  NSString *byPeerId;
  int64_t t;
} AVIMRoomCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_RoomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, roomId),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "s",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_S,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, s),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_T,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, t),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "n",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_N,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, n),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "transient",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_Transient,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "roomPeerIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_RoomPeerIdsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, roomPeerIdsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "byPeerId",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRoomCommand_FieldNumber_ByPeerId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMRoomCommand__storage_, byPeerId),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMRoomCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMRoomCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\006\000roomPeerIds\000\007\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMLogsCommand

@implementation AVIMLogsCommand

@dynamic hasCid, cid;
@dynamic hasL, l;
@dynamic hasLimit, limit;
@dynamic hasT, t;
@dynamic hasTt, tt;
@dynamic hasTmid, tmid;
@dynamic hasMid, mid;
@dynamic hasChecksum, checksum;
@dynamic hasStored, stored;
@dynamic hasDirection, direction;
@dynamic hasTIncluded, tIncluded;
@dynamic hasTtIncluded, ttIncluded;
@dynamic hasLctype, lctype;
@dynamic logsArray, logsArray_Count;

typedef struct AVIMLogsCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t l;
  int32_t limit;
  AVIMLogsCommand_QueryDirection direction;
  int32_t lctype;
  NSString *cid;
  NSString *tmid;
  NSString *mid;
  NSString *checksum;
  NSMutableArray *logsArray;
  int64_t t;
  int64_t tt;
} AVIMLogsCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "cid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_Cid,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, cid),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "l",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_L,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, l),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "limit",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_Limit,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, limit),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt64 = 0LL,
        .core.name = "t",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_T,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, t),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeInt64,
      },
      {
        .defaultValue.valueInt64 = 0LL,
        .core.name = "tt",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_Tt,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, tt),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeInt64,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "tmid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_Tmid,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, tmid),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "mid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_Mid,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, mid),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "checksum",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_Checksum,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, checksum),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "stored",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_Stored,
        .core.hasIndex = 8,
        .core.offset = 9,  // Stored in _has_storage_ to save space.
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeBool,
      },
      {
        .defaultValue.valueEnum = AVIMLogsCommand_QueryDirection_Old,
        .core.name = "direction",
        .core.dataTypeSpecific.enumDescFunc = AVIMLogsCommand_QueryDirection_EnumDescriptor,
        .core.number = AVIMLogsCommand_FieldNumber_Direction,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, direction),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldHasDefaultValue | LCGPBFieldHasEnumDescriptor),
        .core.dataType = LCGPBDataTypeEnum,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "tIncluded",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_TIncluded,
        .core.hasIndex = 11,
        .core.offset = 12,  // Stored in _has_storage_ to save space.
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "ttIncluded",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_TtIncluded,
        .core.hasIndex = 13,
        .core.offset = 14,  // Stored in _has_storage_ to save space.
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeBool,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "lctype",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMLogsCommand_FieldNumber_Lctype,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, lctype),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "logsArray",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMLogItem),
        .core.number = AVIMLogsCommand_FieldNumber_LogsArray,
        .core.hasIndex = LCGPBNoHasBit,
        .core.offset = (uint32_t)offsetof(AVIMLogsCommand__storage_, logsArray),
        .core.flags = LCGPBFieldRepeated,
        .core.dataType = LCGPBDataTypeMessage,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMLogsCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(AVIMLogsCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_FieldsWithDefault];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\013\t\000\014\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum AVIMLogsCommand_QueryDirection

LCGPBEnumDescriptor *AVIMLogsCommand_QueryDirection_EnumDescriptor(void) {
  static _Atomic(LCGPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Old\000New\000";
    static const int32_t values[] = {
        AVIMLogsCommand_QueryDirection_Old,
        AVIMLogsCommand_QueryDirection_New,
    };
    LCGPBEnumDescriptor *worker =
        [LCGPBEnumDescriptor allocDescriptorForName:LCGPBNSStringifySymbol(AVIMLogsCommand_QueryDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AVIMLogsCommand_QueryDirection_IsValidValue];
    LCGPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AVIMLogsCommand_QueryDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case AVIMLogsCommand_QueryDirection_Old:
    case AVIMLogsCommand_QueryDirection_New:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AVIMRcpCommand

@implementation AVIMRcpCommand

@dynamic hasId_p, id_p;
@dynamic hasCid, cid;
@dynamic hasT, t;
@dynamic hasRead, read;
@dynamic hasFrom, from;

typedef struct AVIMRcpCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *cid;
  NSString *from;
  int64_t t;
} AVIMRcpCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRcpCommand_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMRcpCommand__storage_, id_p),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRcpCommand_FieldNumber_Cid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMRcpCommand__storage_, cid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRcpCommand_FieldNumber_T,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMRcpCommand__storage_, t),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "read",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRcpCommand_FieldNumber_Read,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = AVIMRcpCommand_FieldNumber_From,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMRcpCommand__storage_, from),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMRcpCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMRcpCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMReadTuple

@implementation AVIMReadTuple

@dynamic hasCid, cid;
@dynamic hasTimestamp, timestamp;
@dynamic hasMid, mid;

typedef struct AVIMReadTuple__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
  NSString *mid;
  int64_t timestamp;
} AVIMReadTuple__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadTuple_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMReadTuple__storage_, cid),
        .flags = LCGPBFieldRequired,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadTuple_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMReadTuple__storage_, timestamp),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadTuple_FieldNumber_Mid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMReadTuple__storage_, mid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMReadTuple class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMReadTuple__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMMaxReadTuple

@implementation AVIMMaxReadTuple

@dynamic hasPid, pid;
@dynamic hasMaxAckTimestamp, maxAckTimestamp;
@dynamic hasMaxReadTimestamp, maxReadTimestamp;

typedef struct AVIMMaxReadTuple__storage_ {
  uint32_t _has_storage_[1];
  NSString *pid;
  int64_t maxAckTimestamp;
  int64_t maxReadTimestamp;
} AVIMMaxReadTuple__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "pid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMMaxReadTuple_FieldNumber_Pid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMMaxReadTuple__storage_, pid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "maxAckTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMMaxReadTuple_FieldNumber_MaxAckTimestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMMaxReadTuple__storage_, maxAckTimestamp),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "maxReadTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMMaxReadTuple_FieldNumber_MaxReadTimestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMMaxReadTuple__storage_, maxReadTimestamp),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMMaxReadTuple class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMMaxReadTuple__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\017\000\003\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMReadCommand

@implementation AVIMReadCommand

@dynamic hasCid, cid;
@dynamic cidsArray, cidsArray_Count;
@dynamic convsArray, convsArray_Count;

typedef struct AVIMReadCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
  NSMutableArray *cidsArray;
  NSMutableArray *convsArray;
} AVIMReadCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadCommand_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMReadCommand__storage_, cid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReadCommand_FieldNumber_CidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMReadCommand__storage_, cidsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "convsArray",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMReadTuple),
        .number = AVIMReadCommand_FieldNumber_ConvsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMReadCommand__storage_, convsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeMessage,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMReadCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMReadCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMPresenceCommand

@implementation AVIMPresenceCommand

@dynamic hasStatus, status;
@dynamic sessionPeerIdsArray, sessionPeerIdsArray_Count;
@dynamic hasCid, cid;

typedef struct AVIMPresenceCommand__storage_ {
  uint32_t _has_storage_[1];
  AVIMStatusType status;
  NSMutableArray *sessionPeerIdsArray;
  NSString *cid;
} AVIMPresenceCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = AVIMStatusType_On,
        .core.name = "status",
        .core.dataTypeSpecific.enumDescFunc = AVIMStatusType_EnumDescriptor,
        .core.number = AVIMPresenceCommand_FieldNumber_Status,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(AVIMPresenceCommand__storage_, status),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldHasEnumDescriptor),
        .core.dataType = LCGPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "sessionPeerIdsArray",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMPresenceCommand_FieldNumber_SessionPeerIdsArray,
        .core.hasIndex = LCGPBNoHasBit,
        .core.offset = (uint32_t)offsetof(AVIMPresenceCommand__storage_, sessionPeerIdsArray),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "cid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMPresenceCommand_FieldNumber_Cid,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(AVIMPresenceCommand__storage_, cid),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMPresenceCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(AVIMPresenceCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_FieldsWithDefault];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000sessionPeerIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMReportCommand

@implementation AVIMReportCommand

@dynamic hasInitiative, initiative;
@dynamic hasType, type;
@dynamic hasData_p, data_p;

typedef struct AVIMReportCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSString *data_p;
} AVIMReportCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "initiative",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReportCommand_FieldNumber_Initiative,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReportCommand_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMReportCommand__storage_, type),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMReportCommand_FieldNumber_Data_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMReportCommand__storage_, data_p),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMReportCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMReportCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMPatchItem

@implementation AVIMPatchItem

@dynamic hasCid, cid;
@dynamic hasMid, mid;
@dynamic hasTimestamp, timestamp;
@dynamic hasRecall, recall;
@dynamic hasData_p, data_p;
@dynamic hasPatchTimestamp, patchTimestamp;
@dynamic hasFrom, from;
@dynamic hasBinaryMsg, binaryMsg;
@dynamic hasMentionAll, mentionAll;
@dynamic mentionPidsArray, mentionPidsArray_Count;
@dynamic hasPatchCode, patchCode;
@dynamic hasPatchReason, patchReason;

typedef struct AVIMPatchItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
  NSString *mid;
  NSString *data_p;
  NSString *from;
  NSData *binaryMsg;
  NSMutableArray *mentionPidsArray;
  NSString *patchReason;
  int64_t timestamp;
  int64_t patchTimestamp;
  int64_t patchCode;
} AVIMPatchItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, cid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, mid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, timestamp),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "recall",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_Recall,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_Data_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, data_p),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "patchTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_PatchTimestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, patchTimestamp),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_From,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, from),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "binaryMsg",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_BinaryMsg,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, binaryMsg),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBytes,
      },
      {
        .name = "mentionAll",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_MentionAll,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeBool,
      },
      {
        .name = "mentionPidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_MentionPidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, mentionPidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "patchCode",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_PatchCode,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, patchCode),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "patchReason",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchItem_FieldNumber_PatchReason,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AVIMPatchItem__storage_, patchReason),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMPatchItem class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMPatchItem__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\006\016\000\010\t\000\t\n\000\n\000mentionPids\000\013\t\000\014\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMPatchCommand

@implementation AVIMPatchCommand

@dynamic patchesArray, patchesArray_Count;
@dynamic hasLastPatchTime, lastPatchTime;

typedef struct AVIMPatchCommand__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *patchesArray;
  int64_t lastPatchTime;
} AVIMPatchCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "patchesArray",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMPatchItem),
        .number = AVIMPatchCommand_FieldNumber_PatchesArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMPatchCommand__storage_, patchesArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "lastPatchTime",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPatchCommand_FieldNumber_LastPatchTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMPatchCommand__storage_, lastPatchTime),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeInt64,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMPatchCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMPatchCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMPubsubCommand

@implementation AVIMPubsubCommand

@dynamic hasCid, cid;
@dynamic cidsArray, cidsArray_Count;
@dynamic hasTopic, topic;
@dynamic hasSubtopic, subtopic;
@dynamic topicsArray, topicsArray_Count;
@dynamic subtopicsArray, subtopicsArray_Count;
@dynamic hasResults, results;

typedef struct AVIMPubsubCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
  NSMutableArray *cidsArray;
  NSString *topic;
  NSString *subtopic;
  NSMutableArray *topicsArray;
  NSMutableArray *subtopicsArray;
  AVIMJsonObjectMessage *results;
} AVIMPubsubCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPubsubCommand_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMPubsubCommand__storage_, cid),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPubsubCommand_FieldNumber_CidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMPubsubCommand__storage_, cidsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "topic",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPubsubCommand_FieldNumber_Topic,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMPubsubCommand__storage_, topic),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "subtopic",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPubsubCommand_FieldNumber_Subtopic,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMPubsubCommand__storage_, subtopic),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "topicsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPubsubCommand_FieldNumber_TopicsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMPubsubCommand__storage_, topicsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "subtopicsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMPubsubCommand_FieldNumber_SubtopicsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMPubsubCommand__storage_, subtopicsArray),
        .flags = LCGPBFieldRepeated,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "results",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMJsonObjectMessage),
        .number = AVIMPubsubCommand_FieldNumber_Results,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMPubsubCommand__storage_, results),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeMessage,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMPubsubCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMPubsubCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMBlacklistCommand

@implementation AVIMBlacklistCommand

@dynamic hasSrcCid, srcCid;
@dynamic toPidsArray, toPidsArray_Count;
@dynamic hasSrcPid, srcPid;
@dynamic toCidsArray, toCidsArray_Count;
@dynamic hasLimit, limit;
@dynamic hasNext, next;
@dynamic blockedPidsArray, blockedPidsArray_Count;
@dynamic blockedCidsArray, blockedCidsArray_Count;
@dynamic allowedPidsArray, allowedPidsArray_Count;
@dynamic failedPidsArray, failedPidsArray_Count;
@dynamic hasT, t;
@dynamic hasN, n;
@dynamic hasS, s;

typedef struct AVIMBlacklistCommand__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  NSString *srcCid;
  NSMutableArray *toPidsArray;
  NSString *srcPid;
  NSMutableArray *toCidsArray;
  NSString *next;
  NSMutableArray *blockedPidsArray;
  NSMutableArray *blockedCidsArray;
  NSMutableArray *allowedPidsArray;
  NSMutableArray *failedPidsArray;
  NSString *n;
  NSString *s;
  int64_t t;
} AVIMBlacklistCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescription fields[] = {
      {
        .name = "srcCid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_SrcCid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, srcCid),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "toPidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_ToPidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, toPidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "srcPid",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_SrcPid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, srcPid),
        .flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "toCidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_ToCidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, toCidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, limit),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt32,
      },
      {
        .name = "next",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_Next,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, next),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "blockedPidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_BlockedPidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, blockedPidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "blockedCidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_BlockedCidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, blockedCidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "allowedPidsArray",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_AllowedPidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, allowedPidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "failedPidsArray",
        .dataTypeSpecific.className = LCGPBStringifySymbol(AVIMErrorCommand),
        .number = AVIMBlacklistCommand_FieldNumber_FailedPidsArray,
        .hasIndex = LCGPBNoHasBit,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, failedPidsArray),
        .flags = (LCGPBFieldFlags)(LCGPBFieldRepeated | LCGPBFieldTextFormatNameCustom),
        .dataType = LCGPBDataTypeMessage,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_T,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, t),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeInt64,
      },
      {
        .name = "n",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_N,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, n),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
      {
        .name = "s",
        .dataTypeSpecific.className = NULL,
        .number = AVIMBlacklistCommand_FieldNumber_S,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AVIMBlacklistCommand__storage_, s),
        .flags = LCGPBFieldOptional,
        .dataType = LCGPBDataTypeString,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMBlacklistCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescription))
                                   storageSize:sizeof(AVIMBlacklistCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_None];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\006\000\002\000toPids\000\003\006\000\004\000toCids\000\010\000blockedPids\000\t"
        "\000blockedCids\000\n\000allowedPids\000\013\000failedPids\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AVIMGenericCommand

@implementation AVIMGenericCommand

@dynamic hasCmd, cmd;
@dynamic hasOp, op;
@dynamic hasAppId, appId;
@dynamic hasPeerId, peerId;
@dynamic hasI, i;
@dynamic hasInstallationId, installationId;
@dynamic hasPriority, priority;
@dynamic hasService, service;
@dynamic hasServerTs, serverTs;
@dynamic hasClientTs, clientTs;
@dynamic hasNotificationType, notificationType;
@dynamic hasDataMessage, dataMessage;
@dynamic hasSessionMessage, sessionMessage;
@dynamic hasErrorMessage, errorMessage;
@dynamic hasDirectMessage, directMessage;
@dynamic hasAckMessage, ackMessage;
@dynamic hasUnreadMessage, unreadMessage;
@dynamic hasReadMessage, readMessage;
@dynamic hasRcpMessage, rcpMessage;
@dynamic hasLogsMessage, logsMessage;
@dynamic hasConvMessage, convMessage;
@dynamic hasRoomMessage, roomMessage;
@dynamic hasPresenceMessage, presenceMessage;
@dynamic hasReportMessage, reportMessage;
@dynamic hasPatchMessage, patchMessage;
@dynamic hasPubsubMessage, pubsubMessage;
@dynamic hasBlacklistMessage, blacklistMessage;

typedef struct AVIMGenericCommand__storage_ {
  uint32_t _has_storage_[1];
  AVIMCommandType cmd;
  AVIMOpType op;
  int32_t i;
  int32_t priority;
  int32_t service;
  int32_t notificationType;
  NSString *appId;
  NSString *peerId;
  NSString *installationId;
  AVIMDataCommand *dataMessage;
  AVIMSessionCommand *sessionMessage;
  AVIMErrorCommand *errorMessage;
  AVIMDirectCommand *directMessage;
  AVIMAckCommand *ackMessage;
  AVIMUnreadCommand *unreadMessage;
  AVIMReadCommand *readMessage;
  AVIMRcpCommand *rcpMessage;
  AVIMLogsCommand *logsMessage;
  AVIMConvCommand *convMessage;
  AVIMRoomCommand *roomMessage;
  AVIMPresenceCommand *presenceMessage;
  AVIMReportCommand *reportMessage;
  AVIMPatchCommand *patchMessage;
  AVIMPubsubCommand *pubsubMessage;
  AVIMBlacklistCommand *blacklistMessage;
  int64_t serverTs;
  int64_t clientTs;
} AVIMGenericCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCGPBDescriptor *)descriptor {
  static LCGPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static LCGPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = AVIMCommandType_Session,
        .core.name = "cmd",
        .core.dataTypeSpecific.enumDescFunc = AVIMCommandType_EnumDescriptor,
        .core.number = AVIMGenericCommand_FieldNumber_Cmd,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, cmd),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldHasEnumDescriptor),
        .core.dataType = LCGPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = AVIMOpType_Open,
        .core.name = "op",
        .core.dataTypeSpecific.enumDescFunc = AVIMOpType_EnumDescriptor,
        .core.number = AVIMGenericCommand_FieldNumber_Op,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, op),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldHasEnumDescriptor),
        .core.dataType = LCGPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "appId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_AppId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, appId),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "peerId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_PeerId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, peerId),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "i",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_I,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, i),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "installationId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_InstallationId,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, installationId),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "priority",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_Priority,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, priority),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "service",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_Service,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, service),
        .core.flags = LCGPBFieldOptional,
        .core.dataType = LCGPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt64 = 0LL,
        .core.name = "serverTs",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_ServerTs,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, serverTs),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeInt64,
      },
      {
        .defaultValue.valueInt64 = 0LL,
        .core.name = "clientTs",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_ClientTs,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, clientTs),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeInt64,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "notificationType",
        .core.dataTypeSpecific.className = NULL,
        .core.number = AVIMGenericCommand_FieldNumber_NotificationType,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, notificationType),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "dataMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMDataCommand),
        .core.number = AVIMGenericCommand_FieldNumber_DataMessage,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, dataMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "sessionMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMSessionCommand),
        .core.number = AVIMGenericCommand_FieldNumber_SessionMessage,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, sessionMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "errorMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMErrorCommand),
        .core.number = AVIMGenericCommand_FieldNumber_ErrorMessage,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, errorMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "directMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMDirectCommand),
        .core.number = AVIMGenericCommand_FieldNumber_DirectMessage,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, directMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "ackMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMAckCommand),
        .core.number = AVIMGenericCommand_FieldNumber_AckMessage,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, ackMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "unreadMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMUnreadCommand),
        .core.number = AVIMGenericCommand_FieldNumber_UnreadMessage,
        .core.hasIndex = 16,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, unreadMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "readMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMReadCommand),
        .core.number = AVIMGenericCommand_FieldNumber_ReadMessage,
        .core.hasIndex = 17,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, readMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rcpMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMRcpCommand),
        .core.number = AVIMGenericCommand_FieldNumber_RcpMessage,
        .core.hasIndex = 18,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, rcpMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "logsMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMLogsCommand),
        .core.number = AVIMGenericCommand_FieldNumber_LogsMessage,
        .core.hasIndex = 19,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, logsMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "convMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMConvCommand),
        .core.number = AVIMGenericCommand_FieldNumber_ConvMessage,
        .core.hasIndex = 20,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, convMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "roomMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMRoomCommand),
        .core.number = AVIMGenericCommand_FieldNumber_RoomMessage,
        .core.hasIndex = 21,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, roomMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "presenceMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMPresenceCommand),
        .core.number = AVIMGenericCommand_FieldNumber_PresenceMessage,
        .core.hasIndex = 22,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, presenceMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "reportMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMReportCommand),
        .core.number = AVIMGenericCommand_FieldNumber_ReportMessage,
        .core.hasIndex = 23,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, reportMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "patchMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMPatchCommand),
        .core.number = AVIMGenericCommand_FieldNumber_PatchMessage,
        .core.hasIndex = 24,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, patchMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "pubsubMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMPubsubCommand),
        .core.number = AVIMGenericCommand_FieldNumber_PubsubMessage,
        .core.hasIndex = 25,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, pubsubMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "blacklistMessage",
        .core.dataTypeSpecific.className = LCGPBStringifySymbol(AVIMBlacklistCommand),
        .core.number = AVIMGenericCommand_FieldNumber_BlacklistMessage,
        .core.hasIndex = 26,
        .core.offset = (uint32_t)offsetof(AVIMGenericCommand__storage_, blacklistMessage),
        .core.flags = (LCGPBFieldFlags)(LCGPBFieldOptional | LCGPBFieldTextFormatNameCustom),
        .core.dataType = LCGPBDataTypeMessage,
      },
    };
    LCGPBDescriptor *localDescriptor =
        [LCGPBDescriptor allocDescriptorForClass:[AVIMGenericCommand class]
                                     rootClass:[AVIMMessagesProtoOrigRoot class]
                                          file:AVIMMessagesProtoOrigRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(LCGPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(AVIMGenericCommand__storage_)
                                         flags:LCGPBDescriptorInitializationFlag_FieldsWithDefault];
#if !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\026\003\005\000\004\006\000\006\016\000\t\010\000\n\010\000\013\020\000e\013\000f\016\000g\014\000h\r\000i\n\000j\r\000k\013\000"
        "l\n\000m\013\000n\013\000o\013\000p\017\000q\r\000r\014\000s\r\000t\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !LCGPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
